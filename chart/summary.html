<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="Cache-Control" content="No-Cache">
		
		<title>Status @ ITAhM</title>

		<style>
@import "/css/style.css";
@import "/css/var.css";
@import "/css/fa.css";

body {
	color: #fff;
}

article {
    page-break-inside: avoid;
	display: flex;
	justify-content: space-between;
	flex-wrap: wrap;
}

h2 {
    margin: 0 0 0.5em 0;
    background-color: #777;
    border-radius: 5px 5px 0 0;
    padding: 0.5em;
	text-align: center;
    text-shadow: 0 2px 3px #000;
}

iframe {
    border: none;
    width: 100%; height: 100%;
}

section {
    position: relative;
	padding: 5px;
	background-color: #424242;
    display: flex; flex-direction: column;
    box-sizing: border-box;
    margin: 3px 0;
}

section ul {
    flex: 1;
}

section li {
    position: relative;
}

.information li,
#response li,
#processor li,
#storage li,
#memory li {
    height: 100px;
}

#response li::after {
    display: inline-block;
    position: absolute; top: 100%; left: 50%;
    transform: translate(-50%, -100%);
    content: attr(data-response);
}

/** rtt **/
section.rtt {
    width: 200px;
}

section.rtt ul {
    position: relative;
    display: flex; align-items: center; justify-content: center;
}

section.rtt li {
    position: absolute;
    border-radius: 50%;
}

section.rtt li.rotate {
    height: 100px;
    width: 100px;
}

body:not(.shutdown) section.rtt li.rotate {
    animation: rotate 2s infinite;
    /*background-image: linear-gradient(135deg, #FEED07 0%, #FE6A50 5%, #ED00AA 15%, #2FE3FE 50%, #8900FF 100%);*/
    background-image: linear-gradient(135deg, #dddddd 0%, #FE6A50 5%, #f6bf26 15%, #00897b 50%, #8e24aa 100%);
}

section.rtt li.background {
    height: 90px;
    width: 90px;
    /*background-image: linear-gradient(0deg, #36295e, #1c1045);*/
    background-color: #424242;
}

section.rtt li.background {
    font: 2em "Font Awesome 5 Free";
}

section.rtt li.content {
    font-weight: bold;
    font-size: 1.6em;
}

section.dummy {
    flex: 1;
}

/****/

#processor,
#storage {
    display: flex;
}

#storage {
    flex-wrap: wrap;
}

#processor li {
    width: 120px; 
}

#processor li::after {
    display: inline-block;
    position: absolute; top: 100%; left: 50%;
    transform: translate(-50%, -100%);
}

#processor li:nth-child(1)::after {
    content: "최소";
}

#processor li:nth-child(2)::after {
    content: "평균";
}

#processor li:nth-child(3)::after {
    content: "최대";
}

#response li,
#storage li,
#memory li {
    width: 200px;
}

#portmap li {
    flex: none; width: 80px;
}

#portmap li label {
    position: absolute; top: 0; right: 0;
    display: none;
    cursor: pointer;
}

#portmap li label::before {
    font: 2em "Font Awesome 5 Free";
    content: "\f071";
}

#portmap li.error label {
    color: #ff0000;
    display: initial;
}

#portmap li:hover label {
    display: initial;
}

section.enterprise {
    flex: none; width: 160px;
}

section.type {
    flex: none; width: 120px;
}

/** Interface **/
section.interface {
    width: 100%;
}

section.interface table {
    border-collapse: collapse;
	width: 100%;
	table-layout: fixed;
}

section.interface thead {
    background-color: #34495e;
}

section.interface tbody tr {
    border: 1px solid transparent;
    border-bottom-color: #663399;
}

section.interface th {
    padding: 1em 0;
}

section.interface td {
    line-height: 3em;
    position: relative;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    padding: 0 1em;
}

section.interface td:nth-child(1) {
    text-align: center;
    font-family: "Font Awesome 5 Free";
}

section.interface td:nth-child(1)::before {
    content: "\f796";
    transform: rotate(180deg);
    position: absolute; inset: 0 0 0 0;
    font-size: 2em;
    color: var(--var-color-normal);
    background-color: rgba(0, 0, 0, 0.5);
}

section.interface tr[data-status=shutdown] td:nth-child(1)::before {
    color: var(--var-color-shutdown);
}

section.interface tr[data-status=critical] td:nth-child(1)::before {
    color: var(--var-color-critical);
}

section.interface tr[data-status=disabled] td:nth-child(1)::before {
    color: var(--var-color-disabled);
}

section.interface td:nth-child(4),
section.interface td:nth-child(6),
section.interface td:nth-child(8) {
    text-align: center;
}

section.interface td:nth-child(5),
section.interface td:nth-child(7) {
    background: linear-gradient(to right,
        var(--var-color-normal) 70%,
        var(--var-color-critical) 70%,
        var(--var-color-critical) 90%,
        var(--var-color-shutdown) 90%)
}

section.interface
:is(tr[data-status=shutdown], tr[data-status=disabled])
:is(td:nth-child(5), td:nth-child(7)) {
    background: none;
}

section.interface
:is(tr[data-status=shutdown], tr[data-status=disabled])
:is(td:nth-child(5), td:nth-child(7))
div {
    display: none;
}

section.interface
:is(td:nth-child(5), td:nth-child(7))::after {
    content: attr(data-value);
    position: relative;
}

section.interface
:is(td:nth-child(5),td:nth-child(7))
div {
    position: absolute; inset: 0 0 0 0;
    background-color:#303030;
    animation: gauge 1s;
}

@keyframes gauge {
    30% {left: 0}
}
/** Interface **/

section.enterprise ul,
section.type ul {
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    margin: 1em;
}

section.information {
    flex: 1 0;
}

section.portmap {
    width: 100%;
    position: relative;
}

.selectable {
    border: 1px solid transparent;
    cursor: pointer;
}
.selectable:hover {
    border: 1px dotted #ddd;
}

.status::after {
	content: "";
	position: absolute; top: 1em; left: 1em;
	display: inline-block;
	width: 20px; height: 20px;
	border-radius: 50%;
	background-color: #0f0;
}

.status.critical::after {
	background-color: #ffa500;
}

.status.shutdown::after {
	background-color: #ff0000;
}

.container {
    display: flex;
}

ul {
	list-style: none;
	margin: 0; padding: 0;
}

label.switch {
    position: absolute; top: 10px; right: 10px;
    font: 2em 'Font Awesome 5 Free';
}

label.switch .on {
    color: #ffffff;
}

label.switch .off {
    color: #aaaaaa;
}

#toggle {
    display: none;
}

#portmap {    
    display: flex;
    overflow-x: auto;
}

#toggle:checked ~#portmap {
    flex-wrap: wrap;
}

#fan li {
    width: 120px;
    display: inline-flex; justify-content: center; align-items: center;
    background: url(/img/fan.png) no-repeat center;
    background-size: contain;
}

#fan li::before {
    font: 80px "Font Awesome 5 Free";
    content: "\f863";
    color: #8e24aa;
    animation: critical 1s infinite;
}

#fan li.normal::before {
    color: #00897b;
    animation: rotate 2s linear infinite;
}

#power li {
    width: 120px;
    display: inline-flex; justify-content: center; align-items: center;
    overflow: hidden;
}

#power li::before {
    font: 80px "Font Awesome 5 Free";
    content: "\f1e6";
    -webkit-background-clip: text;
	-webkit-text-fill-color: transparent;
}

#power li.normal::before {
	background-image: linear-gradient(#c0c0c0, #c0c0c0 30%, #00897b 30%, #00897b 65%, #303030 75%);
    animation: power 1s;
}

#power li:not(.normal)::before {
    background-image: linear-gradient(#c0c0c0, #c0c0c0 30%, #8e24aa 30%, #8e24aa 65%, #303030 75%);
    animation: critical 1s infinite;
}

#temperature li {
    width: 120px;
    display: inline-flex; justify-content: center;
}

#temperature li label {
    font-size: 16px;
    font-weight: bold;
    position: absolute;
    inset: auto auto 5px 5px;
}

#temperature li::before {
    font: 80px "Font Awesome 5 Free";
    content: "\f2c7";
    align-self: center;
    -webkit-background-clip: text;
	-webkit-text-fill-color: transparent;
	background-image: linear-gradient(red, red 30%, orange 30%, orange 60%, green 60%);
    transform: translateX(20px);
}

div.tbody {
	text-align: initial;
}

.title {
	padding: 0.5em 0;
	border-bottom: 1px solid #ddd;
	margin-bottom: 3px;
}

.title >li {
	text-align: center;
	font-weight: bold;
	margin: 0.5em 0;
}

.title >li:not(:last-of-type) {
	border-right: 1px solid #555;
}

section.information table {
	border-collapse: collapse;
	width: 100%; min-width: 300px;
	table-layout: fixed;
}

section.information th {
	text-align: right;
    font-weight: bold;
	width: 80px;
}

section.information td { 
	text-align: left;
	white-space: nowrap;
	text-overflow: ellipsis;
	overflow: hidden;
}

section.information th,
section.information td {
	padding: 3px 1em;
}

div.flex {
	display: flex;
}

div.flex span {
	flex: 1;
}

body:not(.response) section.response,
body:not(.response) section.rtt,
body:not(.processor) section.processor,
body:not(.storage) section.storage,
body:not(.memory) section.memory,
body:not(.portmap) section.portmap,
body:not(.interface) section.interface,
body:not(.power) section.power,
body:not(.temperature) section.temperature,
body:not(.fan) section.fan,
body.shutdown .status::after,
#toggle:checked ~label.switch .off,
#toggle:not(:checked) ~label.switch .on {
	display: none;
}

@keyframes rotate {
    0% {
        transform:rotate(0deg);
    }
    100% {
        transform:rotate(360deg);
    }
}

@keyframes power {
    0% {
        transform: translateY(100%);
    }
    100% {
        transform: none;
    }
}

@keyframes critical {
    0% {
        opacity: 0.5;
    }
    50% {
        opacity: 1;
    }
}
		</style>
		
		<script>

function Interface() {
    //this.initialize(arguments);
}

{
    const UNIT = ["bps", "Kbps", "Mbps", "Gbps", "Tbps"];

    function toBPSString(value) {    
        for(var i=0, _i=UNIT.length -1; i<_i; i++) {
            if (value > 999) {
                value /= 1000;
            }
            else {
                break;
            }
        }
        
        return `${value.toFixed(2)}${UNIT[i]}`;
    }

    Interface.Port = function (container, config) {
        this.container = container;
        this.config = config;
        this.status = container.appendChild(document.createElement("td"));
        this.name = container.appendChild(document.createElement("td"));
        this.descr = container.appendChild(document.createElement("td"));
        this.bandwidth = container.appendChild(document.createElement("td"));
        this.inUse = container.appendChild(document.createElement("td"));
        this.inGauge = this.inUse.appendChild(document.createElement("div"));
        this.inErr = container.appendChild(document.createElement("td"));
        this.outUse = container.appendChild(document.createElement("td"));
        this.outGauge = this.outUse.appendChild(document.createElement("div"));
        this.outErr = container.appendChild(document.createElement("td"));

        this.name.textContent = config.name;
        this.descr.textContent = config.descr;
        this.bandwidth.textContent = toBPSString(config.bandwidth);
        
        if (config.alias) {
            container.title = config.alias;
        }
    };

    Interface.Port.prototype = {
        set: function (inBPS, outBPS, inErr, outErr) {
            if (!isNaN(inBPS) && !isNaN(outBPS) && !isNaN(inErr) && !isNaN(outErr)) {
                this.inUse.dataset.value = toBPSString(inBPS);
                this.inGauge.style.left = this.inUse.title = `${(inBPS / this.config.bandwidth *100).toFixed(2)}%`;
                this.inUse.appendChild(this.inGauge);

                this.outUse.dataset.value = toBPSString(outBPS);
                this.outGauge.style.left = this.outUse.title = `${(outBPS / this.config.bandwidth *100).toFixed(2)}%`;
                this.outUse.appendChild(this.outGauge);

                this.inErr.textContent = inErr;
                this.outErr.textContent = outErr;
            } else {
                this.inUse.dataset.value = "";
                this.inGauge.style.left = 0;

                this.outUse.dataset.value = ""
                this.outGauge.style.left = 0;

                this.inErr.textContent = "";
                this.outErr.textContent = "";
            }
        }
    };
}

function PortMap() {
    this.initialize(arguments);
}

{
    PortMap.prototype = {
        initialize: function(args) {
            this.container = args[0];
            this.indexToPort = new Map();
        },
        add: function (index, indexData) {
            const container = document.createElement("li");
            let bandwidth = 0, label = "", names = [];

            if (ITAhM.snmp.oid.ifSpeed in indexData) {
                bandwidth = Number(indexData[ITAhM.snmp.oid.ifSpeed]);

                if (ITAhM.snmp.oid.ifHighSpeed in indexData) {
                    const speed = indexData[ITAhM.snmp.oid.ifHighSpeed] *1000000;

                    if (speed > bandwidth) {
                        bandwidth = speed;
                    }
                }
            } else if (ITAhM.snmp.oid.ifHighSpeed in indexData) {
                bandwidth = Number(indexData[ITAhM.snmp.oid.ifHighSpeed]) *1000000;
            }

            if (bandwidth <= 0) {
                return;
            }

            if (!(ITAhM.snmp.oid.ifAdminStatus in indexData)) {
                return;
            }

            if (!(ITAhM.snmp.oid.ifOperStatus in indexData)) {
                return;
            }

            if (ITAhM.snmp.oid.ifHCInOctets in indexData && ITAhM.snmp.oid.ifHCOutOctets in indexData) {
                this.prefix = "ifHC"
            } else if (ITAhM.snmp.oid.ifInOctets in indexData && ITAhM.snmp.oid.ifOutOctets in indexData) {
                this.prefix = "if"
            } else {
                return;
            }

            [ITAhM.snmp.oid.ifName, ITAhM.snmp.oid.ifDescr, ITAhM.snmp.oid.ifAlias].forEach(name => indexData[name] && names.push(indexData[name]));

            if (names.length === 0) {
                return;
            }

            names.sort((n1, n2) => n1.length - n2.length);

            container.appendChild(document.createElement("label")).onclick = e => {
                e.stopPropagation();
                
                onSelectResource({
                    chart: "/chart/error.html",
                    index: index,
                    title: names[0]
                });
            };

            container.classList.add("selectable");

            container.onclick = e => onSelectResource({
                chart: "/chart/throughput.html",
                index: index,
                oid: this.prefix,
                max: bandwidth,
                unit: 8,
                title: names[0]
            });

            this.indexToPort.set(index, new Ethernet(this.container.appendChild(container), {
                image: $.loader.map["/img/ethernet.png"],
                bandwidth: bandwidth,
                label: names[0]
            }));

            container.title = names.pop();

            return true;
        },
        set: function (port, indexData) {
            try {
                const
                    ifAdminStatus = Number(indexData[ITAhM.snmp.oid.ifAdminStatus]),
                    ifOperStatus = Number(indexData[ITAhM.snmp.oid.ifOperStatus]),
                    inOctets = indexData[ITAhM.snmp.oid[`${this.prefix}InOctets`]],
                    outOctets = indexData[ITAhM.snmp.oid[`${this.prefix}OutOctets`]],
                    inErrors = Number(indexData[ITAhM.snmp.oid.ifInErrors]),
                    outErrors = Number(indexData[ITAhM.snmp.oid.ifOutErrors]);

                if (ifAdminStatus !== 1) {
                    port.status(Ethernet.STATUS_DISABLED);
                    port.set();
                } else if (ifOperStatus !==1) {
                    port.status(Ethernet.STATUS_SHUTDOWN);
                    port.set();
                } else {
                    port.set(Number(inOctets) * 8, Number(outOctets) * 8);
                }
                
                port.container.classList[inErrors > 0 || outErrors > 0? "add": "remove"]("error");
            } catch (e) {
                console.error(e);
            }
        },
        update: function (resourceData, criticalData) {
            for (let [index, port] of this.indexToPort) {
                if (criticalData[index]?.[ITAhM.snmp.oid[`${this.prefix}InOctets`]] === false || criticalData[index]?.[ITAhM.snmp.oid[`${this.prefix}OutOctets`]] === false) {
                    port.status(Ethernet.STATUS_CRITICAL);
                } else {
                    port.status(Ethernet.STATUS_NORMAL);
                }

                this.set(port, resourceData[index]);
            }
        }
    };
}

function Fan() {
    this.initialize(arguments);
}

{let i = 0;
    Fan.prototype = {
        initialize: function (args) {
            this.container = args[0];
            this.indexToContainer = new Map();
        },
        add: function (index) {
            const container = document.createElement("li");
            
            this.indexToContainer.set(index, container);
            
            this.container.appendChild(container);
        },
        set: function (container, indexData) {
            var status = false;

            if (ITAhM.snmp.oid.cisco.ciscoEnvMonFanState in indexData) {
                status = Number(indexData[ITAhM.snmp.oid.cisco.ciscoEnvMonFanState]) === 1;
            } else if (ITAhM.snmp.oid.piolink.hFANStatus in indexData) {
                status = Number(indexData[ITAhM.snmp.oid.piolink.hFANStatus]) === 2;
            } else if (ITAhM.snmp.oid.axgate.fanStatus in indexData) {
                status = Number(indexData[ITAhM.snmp.oid.axgate.fanStatus]) === 1;
            } else if (ITAhM.snmp.oid.juniper.jnxOperatingStateFan in indexData) {
                status = Number(indexData[ITAhM.snmp.oid.juniper.jnxOperatingStateFan]) === 2;
            }

            container.classList[status? "add": "remove"]("normal");

            return status;
        },
        update: function (resourceData, criticalData) {
            var status = 0;

            for (let [index, container] of this.indexToContainer) {
                if (this.set(container, resourceData[index])) {
                    status++;
                }
            }
            
            if (this.indexToContainer.size === status) {
                const classList = document.body.querySelector(".fan.status").classList;

                ["critical", "shutdown"].forEach(status => classList.remove(status));
            } else if (this.indexToContainer.size === 0) {
                const classList = document.body.querySelector(".fan.status").classList;

                classList.remove("critical");
                classList.add("shutdown");
            } else {
                const classList = document.body.querySelector(".fan.status").classList;

                classList.remove("shutdown");
                classList.add("critical");
            }
        }
    };
}

function Power() {
    this.initialize(arguments);
}

{
    Power.prototype = {
        initialize: function (args) {
            this.container = args[0];
            this.indexToContainer = new Map();
        },
        add: function (index, indexData) {
            const container = document.createElement("li");
            
            this.indexToContainer.set(index, container);
            
            this.container.appendChild(container);
        },
        set: function (container, indexData) {
            var status = false;
        
            if (ITAhM.snmp.oid.axgate.powerStatus in indexData) {
                status = Number(indexData[ITAhM.snmp.oid.axgate.powerStatus]) === 1;
            }
            
            container.classList.remove("normal");

            status && container.classList.add("normal");
            
            return status;
        },
        update: function (resourceData, criticalData) {
            var status = 0;

            for (let [index, container] of this.indexToContainer) {
                if (this.set(container, resourceData[index])) {
                    status++;
                }
            }
            
            if (this.indexToContainer.size === status) {
                const classList = document.body.querySelector(".power.status").classList;

                ["critical", "shutdown"].forEach(status => classList.remove(status));
            } else if (this.indexToContainer.size === 0) {
                const classList = document.body.querySelector(".power.status").classList;

                classList.remove("critical");
                classList.add("shutdown");
            } else {
                const classList = document.body.querySelector(".power.status").classList;

                classList.remove("shutdown");
                classList.add("critical");
            }
        }
    };
}

function Temperature() {
    this.initialize(arguments);
}

{
    Temperature.prototype = {
        initialize: function (args) {
            this.container = args[0];
            this.indexToContainer = new Map();
        },
        add: function (index, oid) {
            const container = document.createElement("li");
            
            container.appendChild(document.createElement("label"));

            this.indexToContainer.set(index, container);
            
            container.classList.add("status", "selectable");

            container.dataset.oid = oid;

            container.onclick = e => onSelectResource({
                chart: "/chart/temperature.html",
                oid: oid,
                index: index,
                unit: 0.1
            });

            this.container.appendChild(container);
        },
        set: function (container, indexData) {
            if (ITAhM.snmp.oid.axgate.temperature in indexData) {
                container.querySelector("label")
                    .textContent = `${(Number(indexData[ITAhM.snmp.oid.axgate.temperature]) /10).toFixed(1)} ${String.fromCodePoint("0x2103")}`;
            }
        },
        update: function (resourceData, criticalData) {
            var status = 0;

            for (let [index, container] of this.indexToContainer) {
                container.classList[criticalData[index]?.[container.dataset.oid] === false? "add": "remove"]("critical");

                this.set(container, resourceData[index]);
            }
        }
    };
}

function Processor() {
    this.initialize(arguments);
}

{
    const 
        options = {
            cutoutPercentage: 70,
            circumference: Math.PI,
            rotation: Math.PI *-1
        },
        COLOR_GREEN = "#00897b", //"#2FE3FE",
        COLOR_ORANGE = "#f6bf26",//"#FE6A50"
        COLOR_RED = "#8e24aa", //"#8900FF",
        COLOR_NULL = "transparent",
        COLOR_GAUGE = "#dddddd";

    Processor.prototype = {
        initialize: function (args) {
            this.container = args[0];
            this.indexToOID = new Map();

            const
                min = document.createElement("li"),
                avg = document.createElement("li"),
                max = document.createElement("li"),
                df = document.createDocumentFragment();
            
            this.min = new Chart(min.appendChild(document.createElement("canvas")), {
                type: "doughnut",
                data: {
                    datasets: [{
                        data: [70, 20, 10],
                        backgroundColor: [COLOR_GREEN, COLOR_ORANGE, COLOR_RED]
                    }]
                },
                options: options
            });
            
            this.avg = new Chart(avg.appendChild(document.createElement("canvas")), {
                type: "doughnut",
                data: {
                    datasets: [{
                        data: [70, 20, 10],
                        backgroundColor: [COLOR_GREEN, COLOR_ORANGE, COLOR_RED]
                    }]
                },
                options: options
            });

            this.max = new Chart(max.appendChild(document.createElement("canvas")), {
                type: "doughnut",
                data: {
                    datasets: [{
                        data: [70, 20, 10],
                        backgroundColor: [COLOR_GREEN, COLOR_ORANGE, COLOR_RED],
                        borderWidth: 0
                    }]
                },
                options: options
            });

            df.appendChild(min);
            df.appendChild(avg);
            df.appendChild(max);

            this.container.appendChild(df);
        },
        add: function (index, oid) {
            this.indexToOID.set(index, oid);

            this.container.onclick = e => onSelectResource({
                chart: "/chart/processor.html",
                oid: oid
            });
        },
        set: function (index, value) {
            const chart = this[index];

            chart.config.data.datasets[1] = {
                data: [value, 100 - value],
                backgroundColor: [COLOR_GAUGE, COLOR_NULL]
            };
            
            chart.config.label = `${value.toFixed(2)}%`;

            chart.update();
        },
        update: function (resourceData, criticalData) {
            if (this.indexToOID.size === 0) {
                return;
            }
            
            const
                array = [],
                classList = document.body.querySelector("section.processor.status").classList;

            classList.remove("critical");

            for (let [index, oid] of this.indexToOID) {
                array.push(Number(resourceData[index][oid]));

                if (criticalData[index]?.[oid] === false) {
                    classList.add("critical");
                }
            }

            this.set("max", Math.max.apply(undefined, array));
            this.set("min", Math.min.apply(undefined, array));
            this.set("avg", array.reduce((a, b) => a + b) / array.length);
        }
    };
}

function Response() {
    this.initialize(arguments);
}

{
    Response.prototype = {
        initialize: function (args) {
            this.container = args[0];
            this.indexToContainer = new Map();
        },
        set: function (container, indexData) {
            const rtt = indexData[ITAhM.snmp.oid.corebrg.responseTime];

            container.querySelector("li.content").textContent = `${rtt}ms`;
        },
        update: function (resourceData, criticalData) {
            const classList = document.body.querySelector(".rtt.status").classList;

            classList.remove("shutdown", "critical");

            for (let [index, container] of this.indexToContainer) {
                this.set(container, resourceData[index]);

                if (index in criticalData && ITAhM.snmp.oid.corebrg.responseTime in criticalData[index]) {
                    classList.add("critical");
                }
            }
        },
        add: function (index, indexData) {
            this.indexToContainer.set(index, this.container);
        }
    };
}

function Storage() {
    this.initialize(arguments);
}

{
    const
        options = {
            scales: {
                xAxes: [{
                    stacked: true,
                    gridLines: {
                        display: false
                    },
                    ticks: {
                        fontColor: "#ffffff",
                        callback: value => value.substr(0, 30)
                    }
                }],
                yAxes: [{
                    stacked: true,
                    gridLines: {
                        display: false
                    },
                    ticks: {
                        display: false,
                        max: 100,
                        min: 0
                    }
                }]
            },
            layout: {
                padding: {
                    right: 20,
                    left: 20
                }
            }
        },
        COLOR_GREEN = "#00897b",
        COLOR_ORANGE = "#f6bf26",
        COLOR_RED = "#8e24aa";

    Storage.prototype = {
        initialize: function (args) {
            this.container = args[0];
            this.indexToContainer = new Map();
        },
        add: function (index, indexData) {
            const isValidData = ITAhM.snmp.oid.hrStorageSize in indexData
                && ITAhM.snmp.oid.hrStorageAllocationUnits in indexData
                && ITAhM.snmp.oid.hrStorageUsed in indexData;
            
            if (!isValidData) {
                return;
            }

            const
                storage = document.createElement("li"),
                canvas = document.createElement("canvas"),
                chart = new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: [indexData[ITAhM.snmp.oid.hrStorageDescr] || ""]
                    },
                    options: options
                });

            this.indexToContainer.set(index, {
                status: storage,
                chart: chart
            });
            
            storage.classList.add("status", "selectable");
            
            if (ITAhM.snmp.oid.hrStorageUsed in indexData) {
                storage.onclick = e => onSelectResource({
                    chart: "/chart/storage.html",
                    index: index,
                    max: Number(indexData[ITAhM.snmp.oid.hrStorageSize]) * Number(indexData[ITAhM.snmp.oid.hrStorageAllocationUnits]),
                    unit: indexData[ITAhM.snmp.oid.hrStorageAllocationUnits],
                    title: indexData[ITAhM.snmp.oid.hrStorageDescr] || undefined
                });
            }

            storage.appendChild(canvas);

            this.container.appendChild(storage);
        },
        set: function (chart, indexData) {
            const
                used = Number(indexData[ITAhM.snmp.oid.hrStorageUsed]), // used
                size = Number(indexData[ITAhM.snmp.oid.hrStorageSize]), // size
                datasets = [{
                    data: [0],
                    backgroundColor: COLOR_GREEN
                }, {
                    data: [0],
                    backgroundColor: COLOR_ORANGE
                }, {
                    data: [0],
                    backgroundColor: COLOR_RED
                }];
            let value = (used / size *100).toFixed(2);

            if (value > 70) {
                datasets[0].data[0] = 70;

                if (value > 90) {
                    datasets[1].data[0] = 20;
                    datasets[2].data[0] = value -90;
                } else {
                    datasets[1].data[0] = value -70;
                }
            } else {
                datasets[0].data[0] = Math.round(value);
            }

            chart.config.label = `${value}%`;
            chart.config.data.datasets = datasets;

            chart.update();
        },
        update: function (resourceData, criticalData) {
            for (let [index, container] of this.indexToContainer) {
                container.status.classList[criticalData[index]?.[ITAhM.snmp.oid.hrStorageUsed] === false? "add": "remove"]("critical");

                this.set(container.chart, resourceData[index]);
            }
        }
    };
}

function initialize(node) {
    let indexData;

    document.title = node.name || node.ip || "Summary";

    node.ip && (document.body.querySelector(".information .node.ip").textContent = node.ip);
    node.name && (document.body.querySelector(".information .node.name").textContent = node.name);

    document.body.classList.add("response");

    {
        const toggle = document.getElementById("toggle");
    
        if (window.localStorage.getItem("toggle")) {
            toggle.checked = true;
        }

        toggle.onclick = e => {
            if (toggle.checked) {
                window.localStorage.setItem("toggle", "on");
            } else {
                window.localStorage.removeItem("toggle");
            }
        }
    }

    {
        const container = document.body.querySelector("section.type ul");
        let icon = ITAhM.iconData["unknown"];
        
        if (node.type) {
            if (node.type in $.iconData) {
                icon = $.iconData[node.type];
            } else if (node.type in ITAhM.iconData) {
                icon = ITAhM.iconData[node.type];
            }
        }
    
        container.style.backgroundImage = `url(${icon.src})`;
        container.title = icon.type;
    }

    for (let index in node.resource) {
        indexData = node.resource[index];

        //sysName
        (function(sysName) {
            if (sysName) {
                document.body.querySelector(".information .snmp.name").textContent = sysName;
            }
        })(indexData[ITAhM.snmp.oid.sysName]);

        //sysDescr
        (function(sysDescr) {
            if (sysDescr) {
                document.body.querySelector(".information .snmp.descr").textContent = sysDescr;
            }
        })(indexData[ITAhM.snmp.oid.sysDescr]);

        //sysObjectID
        (function(sysObjectID) {
            if (sysObjectID) {
                const enterprise = ITAhM.util.enterpriseFromOID(sysObjectID);

                if (enterprise && enterprise.logo) {
                    document.body.querySelector("section.enterprise ul").style.backgroundImage = `url(${enterprise.logo})`;
                } else {
                    document.body.querySelector("section.enterprise ul").title = sysObjectID;
                }
            }
        })(indexData[ITAhM.snmp.oid.sysObjectID]);

        //responseTime
        if (ITAhM.snmp.oid.corebrg.responseTime in indexData) {
            $.response.add(index, indexData);
        }
        
        //스토리지, 물리 메모리
        if (ITAhM.snmp.oid.hrStorageType in indexData) {
            switch(indexData[ITAhM.snmp.oid.hrStorageType]) {
            case ITAhM.snmp.oid.hrStorageRam:
                document.body.classList.add("memory");

                $.memory.add(index, indexData);

                break;
            case ITAhM.snmp.oid.hrStorageFixedDisk:
                document.body.classList.add("storage");

                $.storage.add(index, indexData);

                break;
            }
        }
        
        // 인터페이스
        (function(descr, type, bandwidth, aStatus, oStatus, inOcts, outOcts, name, alias) {
            if (type && inOcts && outOcts && bandwidth && aStatus && oStatus) {
                document.body.classList.add("portmap");
                if (Number(type) === 6) {
                    $.portMap.add(index, indexData);
                }
            }
        })(indexData[ITAhM.snmp.oid.ifDescr]
            , indexData[ITAhM.snmp.oid.ifType]
            , indexData[ITAhM.snmp.oid.ifHighSpeed] || indexData[ITAhM.snmp.oid.ifSpeed]
            , indexData[ITAhM.snmp.oid.ifAdminStatus]
            , indexData[ITAhM.snmp.oid.ifOperStatus]
            , indexData[ITAhM.snmp.oid.ifHCInOctets] || indexData[ITAhM.snmp.oid.ifInOctets]
            , indexData[ITAhM.snmp.oid.ifHCOutOctets] || indexData[ITAhM.snmp.oid.ifOutOctets]
            , indexData[ITAhM.snmp.oid.ifName]
            , indexData[ITAhM.snmp.oid.ifAlias]);
            
        //FAN
        [
            ITAhM.snmp.oid.cisco.ciscoEnvMonFanState,
            ITAhM.snmp.oid.piolink.hFANStatus,
            ITAhM.snmp.oid.axgate.fanStatus,
            ITAhM.snmp.oid.juniper.jnxOperatingStateFan
        ].forEach(oid => {
            if (oid in indexData) {
                $.fan.add(index, indexData);

                document.body.classList.add("fan");
            }
        });
        //Processor
        [
            ITAhM.snmp.oid.hrProcessorLoad,
            ITAhM.snmp.oid.cisco.cpmCPUTotal5secRev,
            ITAhM.snmp.oid.axgate.hrProcessorLoad
        ].forEach(oid => {
            if (oid in indexData) {
                $.processor.add(index, oid);

                document.body.classList.add("processor");
            }
        });

        //Power
        [
            ITAhM.snmp.oid.axgate.powerStatus
        ].forEach(oid => {
            if (oid in indexData) {
                $.power.add(index, indexData);

                document.body.classList.add("power");
            }
        });
        
        //Temperature
        [
            ITAhM.snmp.oid.axgate.temperature
        ].forEach(oid => {
            if (oid in indexData) {
                $.temperature.add(index, oid)

                document.body.classList.add("temperature");
            }
        });
    }
    
    $.response.update(node.resource, node.critical);
    $.processor.update(node.resource, node.critical);
    $.memory.update(node.resource, node.critical);
    $.storage.update(node.resource, node.critical);
    $.portMap.update(node.resource, node.critical);
    $.fan.update(node.resource, node.critical);
    $.power.update(node.resource, node.critical);
    $.temperature.update(node.resource, node.critical);

    [].forEach.call(document.body.querySelectorAll("section"), section => {
		section.draggable = true;
		
		section.addEventListener("dragstart", function (e) {
			e.stopPropagation();
			
			$.draggable = this;
		});
		
		section.addEventListener("dragover", function (e) {
			e.preventDefault();
			
			if ($.draggable === this) {
				return;
			}
			
			switch ($.draggable) {
			case this.previousElementSibling:
				this.parentNode.insertBefore(this, $.draggable);
				
				break;
			default:
				this.parentNode.insertBefore($.draggable, this);
			}
		});
	});
    
	if (!("status" in node) || !node.status) {
        document.body.classList.add("shutdown");
    } else {
        refresh();
    }

    document.body.classList.remove("loading");
}

function refresh() {
    setTimeout(function () {
        $.request.execute({
            command: "get",
            target: "node",
            id: $.id,
            resource: true
        }, function (e) {
            switch (this.status) {
            case 200:
                break;
            default:
                throw showMessage(this);
            }

            window.requestAnimationFrame(t => update(JSON.parse(this.responseText)));
        })
    }, INTERVAL);
}

function update(node) {
    if (!("resource" in node)) {
        return;
    }

    ["response", "processor", "storage", "memory", "portMap", "fan", "power", "temperature"]
        .forEach(resource => $[resource].update(node.resource, node.critical));

    refresh();
}

function toDateString(millis) {
	var date = new Date(millis),
		ar = [date.getFullYear()],
		mdh = [date.getMonth() +1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()];
	
	for (let i=0, _i=mdh.length, d; i<_i; i++) {
		d = mdh[i];
		
		ar[ar.length] = (d < 10? "0": "")+ d;
	}
	
	return ar[0] +"-"+ ar[1] +"-"+ ar[2] +" "+ ar[3] +":"+ ar[4] +":"+ ar[5];
}

function toElapseString(millis) {
    const elapse = new Date().getTime() - millis;

    if (elapse < 1000) {
        return "1초 미만";
    } else if (elapse < 60 *1000) {
        return `${Math.round(elapse /1000)}초 전`;
    } else if (elapse < 60 *60 *1000) {
        return `${Math.round(elapse /60 /1000)}분 전`;
    } else if (elapse < 24 *60 *60 *1000) {
        return `${Math.round(elapse /60 /60 /1000)}시간 전`;
    } else {
        return `${Math.round(elapse /24 /60 /60 /1000)}일 전`;
    }
}

//private
function onSelectResource(args) {
    const {
            chart, oid, index, max, unit, title
        } = args,
        date = new Date(),
        search = new URLSearchParams();
    
    search.set("id", $.id);
    search.set("name", chart);
    oid && search.set("oid", oid);
    index && search.set("index", index);
    max && search.set("max", max);
    unit && search.set("unit", unit);
    title && search.set("title", title);
    search.set("from", date.setHours(0, 0, 0, 0));
    search.set("to", date.setDate(date.getDate() +1));

    window.location.replace(`/chart/chart.html?${search.toString()}`);
}

function showMessage(xhr) {
    if (xhr instanceof XMLHttpRequest) {
        switch (xhr.status) {
        case 401:
            alert(NOTICE_SESS_EXPIRE["kr"]);

            break;
        default:
            alert(ERROR_RES_CODE(xhr.status)["kr"]);
        }

        try {
            console.log(JSON.parse(xhr.responseText).error);
        } catch (e) {}
    } else if (xhr instanceof Error) {
        console.error(xhr);
    } else {
        console.trace();
    }
}

		</script>
	</head>

	<body class="loading">
		<article>
            <section class="enterprise">
                <h2>정보 공급자</h2>
                <ul></ul>
            </section>
            
			<section class="information">
                <h2 id="node">기본 정보</h2>
                <ul>
                    <li>
                        <table>
                            <tr>
                                <th>이름</th>
                                <td class="node name"></td>
                            </tr>
                            <tr>
                                <th>IP 주소</th>
                                <td class="node ip"></td>
                            </tr>
                            <tr>
                                <th>SNMP 이름</th>
                                <td class="snmp name"></td>
                            </tr>
                            <tr>
                                <th>SNMP 설명</th>
                                <td class="snmp descr"></td>
                            </tr>
                        </table>
                    </li>
                </ul>
			</section>

            <section class="type">
                <h2>종류</h2>
                <ul></ul>
            </section>

            <section class="fan status">
                <h2>팬</h2>
                <ul id="fan" class="container"></ul>
            </section>

            <section class="power status">
                <h2>전원</h2>
                <ul id="power" class="container"></ul>
            </section>

            <section class="temperature">
                <h2>온도</h2>
                <ul id="temperature" class="container">
                </ul>
            </section>

			<section class="processor status">
				<h2>프로세서 로드</h2>
				<ul id="processor" class="container selectable"></ul>
            </section>
            
            <section class="memory">
                <h2>물리 메모리</h2>
                <ul id="memory" class="container"></ul>
            </section>

            <section class="storage">
                <h2>스토리지</h2>
                <ul id="storage" class="container"></ul>
            </section>
			
            <section class="rtt status">
                <h2>응답 시간</h2>
                <ul id="rtt" class="container selectable">
                    <li class="rotate"></li>
                    <li class="background" data-elapse="">&#xf2f2;</li>
                    <li class="content"></li>
                </ul>
            </section>

            <section class="dummy">
            </section>

            <section class="portmap">
				<h2>
                    인터페이스
                </h2>
                <div>
                    <input type="checkbox" id="toggle">
                    <label class="switch" for="toggle">
                        <span class="off">
                            &#xf204;
                        </span>
                        <span class="on">
                            &#xf205;
                        </span>
                    </label>
                    <ul id="portmap"></ul>
                </div>
			</section>

            <section class="interface">
                <table>
                    <colgroup>
                        <col width="60">
                        <col>
                        <col>
                        <col width="180">
                        <col>
                        <col width="160">
                        <col>
                        <col width="160">
                    </colgroup>
                    <thead>
                        <tr>
                            <th>상태</th>
                            <th>이름</th>
                            <th>설명</th>
                            <th>대역폭</th>
                            <th>수신량</th>
                            <th>수신 오류</th>
                            <th>송신량</th>
                            <th>송신 오류</th>
                        </tr>
                    </thead>
                    <tbody id="interface">
                    </tbody>
                </table>
            </section>
		</article>

		<div class="loading mask"></div>
	
		<script src="/js/ITAhM.js"></script>
        <script src="/js/icon.js"></script>
        <script src="/js/snmp.js"></script>
        <script src="/util/gauge.js"></script>
        <script src="/util/ethernet.js"></script>
        <script src="/js/import/chart.js"></script>
        <script>
Chart.defaults.global.defaultFontFamily = "'맑은 고딕', 'Arial', 'Tahoma'";
//Chart.defaults.global.defaultFontSize = 20;
Chart.defaults.global.elements.arc.borderWidth = 0;
Chart.defaults.global.tooltips.enabled = false;
Chart.defaults.global.legend.display = false;

Ethernet.fontColor = "#ffffff";

Chart.Chart.pluginService.register({
    afterDraw: function(chart) {
        if (chart.config.label) {
            const
                width = chart.chart.width,
                text = chart.config.label,
                ctx = chart.chart.ctx;
            let height = chart.chart.height;

            ctx.save();
            
            ctx.fillStyle = "#ffffff";

            switch(chart.config.type) {
            case "doughnut":
                ctx.textBaseline = "bottom";
                ctx.font = `16px "맑은 고딕", Tahoma`;

                break;
            default:
                ctx.textBaseline = "middle";
                ctx.font = `20px "맑은 고딕", Tahoma`;

                height /= 2;
            }

            ctx.fillText(text, Math.round((width - ctx.measureText(text).width) / 2), height);

            ctx.restore();
        }
    },
    beforeDraw: function (chart) {
        if (chart.config.type === "pie") {
            const
                x = chart.chart.width /2,
                y = chart.chart.height /2,
                ctx = chart.chart.ctx;

            ctx.save();
            
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";

            ctx.beginPath();
            ctx.arc(x, y, y -1, 0, Math.PI *2);
            ctx.fill();
            
            ctx.restore();
        }
    }
});
        </script>
        <script src="/js/request.js"></script>
        <script src="/js/constants.js"></script>
        <script src="/js/snmp.js"></script>
        <script src="/util/loader.js"></script>
		<script>

const
    INTERVAL = 10000,
    search = new URLSearchParams(window.location.search),
    $ = {
        request: new Request(),
        id: Number(search.get("id")),
        processorIndexArray: [],
        memoryIndexArray: [],
        storageIndexObj: {},
        response: new Response(document.getElementById("rtt")),
        processor: new Processor(document.getElementById("processor")),
        storage: new Storage(document.getElementById("storage")),
        memory: new Storage(document.getElementById("memory")),
        portMap: new PortMap(document.getElementById("portmap")),
        fan: new Fan(document.getElementById("fan")),
        power: new Power(document.getElementById("power")),
        temperature: new Temperature(document.getElementById("temperature")),
        ethernet: new Image(),
        loader: new ImageLoader(onImageLoad)
    };

document.getElementById("rtt").onclick = e => onSelectResource({
    chart: "/chart/responseTime.html",
    index: "0"
});

function onImageLoad() {
    $.request.query({
        command: "get",
        target: "icon"
    }).then(iconData => {
        $.iconData = iconData || {};

        return $.request.query({
            command: "get",
            target: "node",
            id: $.id,
            resource: true
        });
    }).then(node => {
        initialize(node);
    })
    .catch(showMessage);
}

if ($.id) {
    $.loader.load(["/img/ethernet.png"]);
}


		</script>
	
	</body>
</html>